//	ObjectTalk Scripting Language
//	Copyright (c) 1993-2025 Johan A. Goossens. All rights reserved.
//
//	This work is licensed under the terms of the MIT license.
//	For a copy, see <https://opensource.org/licenses/MIT>.

#version 450 core
#extension GL_GOOGLE_include_directive : require

#include "pbrHelpers.glsl"

layout(local_size_x=16, local_size_y=16, local_size_z=1) in;
layout(set=1, binding=0, rg16) uniform writeonly image2D outTexture;

// Karis 2014
vec2 integrateBRDF(float roughness, float NoV) {
	// normal always points along z-axis for the 2D lookup
	vec3 V = vec3(sqrt(1.0 - NoV * NoV), 0.0, NoV);
	vec3 N = vec3(0.0, 0.0, 1.0);

	float A = 0.0;
	float B = 0.0;
	uint numSamples = 1024;

	for (uint i = 0u; i < numSamples; i++) {
		vec2 Xi = hammersley(i, numSamples);
		// sample microfacet direction
		vec3 H = importanceSampleGGX(Xi, roughness, N);

		// get the light direction
		vec3 L = 2.0 * dot(V, H) * H - V;
		float NoL = clamp(dot(N, L), 0.0f, 1.0f);
		float NoH = clamp(dot(N, H), 0.0f, 1.0f);
		float VoH = clamp(dot(V, H), 0.0f, 1.0f);

		if (NoL > 0.0) {
			// terms besides V are from the GGX PDF we're dividing by
			float V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
			float Fc = pow(1.0 - VoH, 5.0);
			A += (1.0 - Fc) * V_pdf;
			B += Fc * V_pdf;
		}
	}

	return 4.0 * vec2(A, B) / float(numSamples);
}

void main() {
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(outTexture);

	if (coord.x >= size.x || coord.y >= size.y) {
		return;
	}

	vec2 uv = (vec2(coord) + 0.5f) / vec2(size);
	vec2 res = integrateBRDF(max(uv.y, MIN_ROUGHNESS), uv.x);
	imageStore(outTexture, coord, vec4(res, 0.0, 0.0));
}
